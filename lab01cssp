# Step 4 – Login Sessions Deep Dive

This document walks through the reference implementation in `expected_states/step04_login_sessions`. It explains how every file contributes to authenticating users, storing their credentials, and protecting routes with Flask-Login. Diagrams show how the moving pieces collaborate.

## Directory Layout

```mermaid
flowchart TD
    A[Flask App] --> B["__init__.py / App factory"]
    A --> C["auth.py / Auth blueprint"]
    A --> D["views.py / Notes blueprint"]
    A --> E["models.py / SQLAlchemy models"]
    A --> F[templates/]
    A --> G[static/styles.css]
```

All application code for this step lives under `expected_states/step04_login_sessions/app/`. You can drop this folder into a `FLASK_APP` project to run the Step 4 snapshot.

## Configuration & App Factory (`app/__init__.py`)

```python
load_dotenv(Path(__file__).resolve().parent.parent / ".env")
login_manager = LoginManager()
```
- Loads environment variables from `.env` at the repo root. This lets you store secrets such as the MySQL password outside source control.
- Creates a module-level `LoginManager` so every app instance shares the same configuration.

```python
def create_app(test_config: dict | None = None) -> Flask:
    app = Flask(__name__, instance_relative_config=False)
    app.config.update(
        SECRET_KEY=os.getenv("SECRET_KEY", "dev-secret-change-me"),
        SQLALCHEMY_DATABASE_URI=_build_database_uri(),
        SQLALCHEMY_TRACK_MODIFICATIONS=False,
        SESSION_COOKIE_SECURE=True,
        SESSION_COOKIE_HTTPONLY=True,
        SESSION_COOKIE_SAMESITE="Lax",
    )
```
- `create_app` is the Flask application factory. It sets security-focused defaults:
  - `SECRET_KEY` signs cookies and CSRF tokens.
  - `SESSION_COOKIE_*` flags harden the cookie (HTTPS only, HTTP-only, same-site).
  - `SQLALCHEMY_DATABASE_URI` comes from `_build_database_uri` (see below).

```python
    if test_config:
        app.config.update(test_config)
```
- Allows unit tests to override settings (e.g., swapping in SQLite).

```python
    db.init_app(app)
    login_manager.init_app(app)
    login_manager.login_view = "auth.login"
    login_manager.session_protection = "strong"
```
- Attaches the global SQLAlchemy object to the app so it can open DB sessions.
- Hooks Flask-Login into the app:
  - `login_view` tells Flask-Login where to redirect anonymous users.
  - `"strong"` session protection revalidates the session if the user’s IP/user agent changes.

```python
    @login_manager.user_loader
    def load_user(user_id: str) -> User | None:
        if not user_id:
            return None
        return User.query.get(int(user_id))
```
- Flask-Login calls this whenever it needs to rehydrate the current user from the session cookie. It looks up the `User` row by primary key.

```python
    from .auth import auth_bp
    from .views import views_bp
    app.register_blueprint(auth_bp)
    app.register_blueprint(views_bp)
```
- Imports blueprints lazily (after app creation to avoid circular dependencies) and registers them.

```python
    with app.app_context():
        db.create_all()
```
- Ensures the database tables exist before serving requests. In production you’d run migrations instead; for the lab it auto-creates the schema.

```python
def _build_database_uri() -> str:
    host = os.getenv("DB_HOST", "127.0.0.1")
    ...
    return f"mysql+pymysql://{user}:{password}@{host}:{port}/{name}?charset=utf8mb4"
```
- Creates a SQLAlchemy-compatible MySQL URI from environment variables, defaulting to sensible dev values.

## Data Model (`app/models.py`)

```python
db = SQLAlchemy()
```
- A single SQLAlchemy instance shared by all modules. It provides the ORM and connection pooling.

```python
class User(UserMixin, db.Model):
    __tablename__ = "users"

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
```
- Represents accounts in the `users` table.
- `UserMixin` supplies Flask-Login defaults (`is_authenticated`, `is_active`, etc.).
- Stores hashed passwords only (no plaintext!), along with a created timestamp.

```python
    def get_id(self) -> str:
        return str(self.id)
```
- Ensures Flask-Login always receives string identifiers to embed in the session cookie.

### Database Snapshot

```mermaid
erDiagram
    USERS {
        int id PK
        varchar email UK
        varchar password_hash
        datetime created_at
    }
```

- Authentication only needs a single table at this stage. Notes and other entities arrive in later steps.

## Authentication Blueprint (`app/auth.py`)

```python
auth_bp = Blueprint("auth", __name__, url_prefix="/auth")
```
- Names the blueprint `auth`. All routes hang off `/auth`.

### Registration Route

```python
@auth_bp.route("/register", methods=("GET", "POST"))
def register():
    if current_user.is_authenticated:
        return redirect(url_for("views.notes"))
```
- Blocks already-signed-in users from re-registering; sends them to the notes page.

```python
    if request.method == "POST":
        email = request.form.get("email", "").strip().lower()
        password = request.form.get("password", "")
```
- On POST, normalizes the email so logins are case-insensitive.

```python
        if not email or not password:
            flash("Email and password are required.", "error")
            return render_template("register.html")
```
- Validates required fields and uses `flash` to queue a message for the next render.

```python
        if User.query.filter_by(email=email).first():
            flash("An account with that email already exists.", "error")
            return render_template("register.html")
```
- Enforces unique emails via an application-level check (in addition to DB constraint).

```python
        user = User(email=email, password_hash=generate_password_hash(password))
        db.session.add(user)
        db.session.commit()
```
- Generates a salted hash using Werkzeug’s `generate_password_hash`, then persists the new user.

```python
        flash("Account created. Please sign in.", "success")
        return redirect(url_for("auth.login"))
```
- Confirms success and sends the user to the login form.

### Login Route

```python
@auth_bp.route("/login", methods=("GET", "POST"))
def login():
    if current_user.is_authenticated:
        return redirect(url_for("views.notes"))
```
- Prevents authenticated users from hitting the login screen.

```python
    if request.method == "POST":
        email = request.form.get("email", "").strip().lower()
        password = request.form.get("password", "")

        user = User.query.filter_by(email=email).one_or_none()
        if not user or not check_password_hash(user.password_hash, password):
            flash("Invalid email or password.", "error")
            return render_template("login.html")
```
- Looks up the user by normalized email and verifies the supplied password against the stored hash.
- Fails closed: the same message is shown for unknown emails and bad passwords.

```python
        login_user(user)
        flash("Welcome back!", "success")
        return redirect(url_for("views.notes"))
```
- `login_user` writes the user ID into the session cookie, marking the client as authenticated.

### Logout Route

```python
@auth_bp.route("/logout")
@login_required
def logout():
    logout_user()
    flash("Signed out successfully.", "success")
    return redirect(url_for("auth.login"))
```
- `@login_required` ensures only logged-in users can log out, keeping the route simple.
- `logout_user` clears the session and rotation tokens; user lands back on the login form.

## Protected Views (`app/views.py`)

```python
views_bp = Blueprint("views", __name__)

@views_bp.route("/")
@login_required
def notes():
    return render_template("notes.html")
```
- The root url `/` hosts the notes page.
- `@login_required` delegates to Flask-Login; anonymous visitors are redirected to `auth.login`.
- When called, it renders `templates/notes.html`.

## Templates (`app/templates/`)

- `base.html`: Shared layout with page title, header, nav menu, and a content block.
  - Navigation toggles links depending on `current_user.is_authenticated`.
- `login.html`: Extends `base.html`, renders the login form, and links to registration.
- `register.html`: Collects email and password for new accounts.
- `notes.html`: Placeholder content confirming the user is signed in.

Flashed messages are not yet rendered; you could add them later by looping over `get_flashed_messages` in `base.html`.

## Styling (`app/static/styles.css`)

- Defines a simple, consistent look for forms and layout.
- Uses neutral colors and responsive-friendly spacing—enough to make the lab approachable without relying on Bootstrap.

## Request Flow Diagrams

### Successful Login

```mermaid
sequenceDiagram
    participant U as User Browser
    participant A as Flask (auth.login)
    participant DB as MySQL
    U->>A: POST /auth/login (email, password)
    A->>DB: SELECT users WHERE email=?
    DB-->>A: user row
    A->>A: check_password_hash()
    A->>U: Set session cookie<br/>Redirect / (notes)
    U->>A: GET /
    A-->>U: Render notes.html
```

### Session Protection

```mermaid
stateDiagram-v2
    [*] --> Anonymous
    Anonymous --> Authenticated : login_user(user)
    Authenticated --> Anonymous : logout_user() or session invalid
```

- Flask-Login stores the user ID in the signed session cookie.
- On each request, Flask reconstructs `current_user` by calling `load_user`.
- If the session fails validation (expired, tampered, or fails the “strong” checks), Flask-Login reverts to `Anonymous`.

## Putting It Together

At Step 4, Secure Notes now:
- Persists users in MySQL via SQLAlchemy.
- Hashes passwords with Werkzeug and never stores plaintext.
- Uses Flask-Login to manage sessions, enforce authentication, and redirect anonymous users to `/auth/login`.
- Protects the main notes page with `@login_required`.
- Provides registration and login forms styled with the shared base template.

You can run this snapshot with the usual Flask workflow:

```bash
export FLASK_APP=app
flask --app app --debug run
```

Be sure to provision the database (`mysql -u lab_user -p secure_notes_lab < sql/schema.sql`) and set matching credentials in `.env` before starting the server.
